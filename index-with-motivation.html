<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>適応型ポモドーロタイマー</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // 新しい文解放ダイアログコンポーネント
    const NewSentenceDialog = ({ show, sentence, onClose }) => {
      if (!show) return null;

      return React.createElement('div', {
        className: 'fixed inset-0 bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4 z-50'
      },
        React.createElement('div', {
          className: 'bg-white rounded-3xl shadow-xl p-8 max-w-md w-full text-center'
        },
          React.createElement('h2', {
            className: 'text-2xl font-bold text-gray-800 mb-6'
          }, '📚 新しい文を解放しました！'),

          React.createElement('div', {
            className: 'mb-6'
          },
            React.createElement('div', {
              className: 'text-4xl mb-4'
            }, '✨'),

            React.createElement('div', {
              className: 'p-4 bg-blue-50 border border-blue-200 rounded-lg mb-4'
            },
              React.createElement('p', {
                className: 'text-lg text-gray-800 font-medium leading-relaxed'
              }, sentence)
            ),

            React.createElement('div', {
              className: 'text-sm text-gray-600'
            }, '作業お疲れさまでした！次の文が気になりますね...')
          ),

          React.createElement('button', {
            onClick: onClose,
            className: 'w-full bg-purple-500 hover:bg-purple-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
          }, '閉じる')
        )
      );
    };

    // 読書記録画面コンポーネント
    const ReadingHistoryDialog = ({ show, literaryProgress, literaryWorks, onClose, onSelectWork, onDeleteData }) => {
      if (!show) return null;

      return React.createElement('div', {
        className: 'fixed inset-0 bg-gradient-to-br from-indigo-50 to-purple-100 flex items-center justify-center p-4 z-50'
      },
        React.createElement('div', {
          className: 'bg-white rounded-3xl shadow-xl p-8 max-w-md w-full'
        },
          React.createElement('h2', {
            className: 'text-2xl font-bold text-gray-800 mb-6 text-center'
          }, '📚 読書記録'),

          React.createElement('div', {
            className: 'space-y-3 mb-6'
          },
            // 走れメロス
            React.createElement('button', {
              onClick: () => onSelectWork('hashire_melos'),
              className: 'w-full p-4 bg-blue-50 hover:bg-blue-100 border border-blue-200 rounded-lg text-left transition-colors'
            },
              React.createElement('div', {
                className: 'flex justify-between items-center'
              },
                React.createElement('div', {},
                  React.createElement('div', {
                    className: 'font-medium text-gray-800'
                  }, '走れメロス'),
                  React.createElement('div', {
                    className: 'text-sm text-gray-600'
                  }, '太宰治')
                ),
                React.createElement('div', {
                  className: 'text-sm font-medium text-blue-600'
                }, `${literaryProgress.currentSentence + 1}/${literaryWorks.hashire_melos.totalSentences}文`)
              )
            )
          ),
          React.createElement('div', {
            className: 'mb-4 p-3 bg-red-50 border border-red-200 rounded-lg'
          },
            React.createElement('button', {
              onClick: onDeleteData,
              className: 'w-full py-2 px-4 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors text-sm'
            }, '📚 読書データ削除')
          ),

          React.createElement('button', {
            onClick: onClose,
            className: 'w-full bg-gray-500 hover:bg-gray-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
          }, '閉じる')
        )
      );
    };

    // 作品読書画面コンポーネント
    const WorkReadingDialog = ({ show, selectedWork, literaryWorks, literaryProgress, onBack, onClose }) => {
      if (!show || !selectedWork) return null;

      const work = literaryWorks[selectedWork];

      return React.createElement('div', {
        className: 'fixed inset-0 bg-gradient-to-br from-amber-50 to-orange-100 flex items-center justify-center p-4 z-50'
      },
        React.createElement('div', {
          className: 'bg-white rounded-3xl shadow-xl p-8 max-w-lg w-full max-h-[80vh] overflow-y-auto'
        },
          React.createElement('div', {
            className: 'text-center mb-6'
          },
            React.createElement('h2', {
              className: 'text-2xl font-bold text-gray-800 mb-2'
            }, work.title),
            React.createElement('p', {
              className: 'text-gray-600'
            }, `${work.author} 著`),
            React.createElement('div', {
              className: 'text-sm text-blue-600 mt-2'
            }, `読了: ${literaryProgress.currentSentence + 1}/${work.totalSentences}文`)
          ),

          React.createElement('div', {
            className: 'space-y-4 mb-6'
          },
            // 解放済みの文を順番に表示
            ...Array.from({ length: literaryProgress.currentSentence + 1 }, (_, index) =>
              React.createElement('div', {
                key: index,
                className: 'p-4 bg-amber-50 border-l-4 border-amber-400 rounded-r-lg'
              },
                React.createElement('div', {
                  className: 'text-sm text-amber-600 mb-1'
                }, `第${index + 1}文`),
                React.createElement('p', {
                  className: 'text-gray-800 leading-relaxed'
                }, work.sentences[index])
              )
            ),

            // まだ解放されていない文がある場合の表示
            literaryProgress.currentSentence + 1 < work.totalSentences &&
            React.createElement('div', {
              className: 'p-4 bg-gray-100 border-l-4 border-gray-300 rounded-r-lg text-center'
            },
              React.createElement('div', {
                className: 'text-sm text-gray-500 mb-1'
              }, `第${literaryProgress.currentSentence + 2}文`),
              React.createElement('p', {
                className: 'text-gray-500 italic'
              }, '？？？'),
              React.createElement('p', {
                className: 'text-xs text-gray-400 mt-2'
              }, '作業を完了すると続きが読めます')
            )
          ),

          React.createElement('div', {
            className: 'flex space-x-3'
          },
            React.createElement('button', {
              onClick: onBack,
              className: 'flex-1 bg-amber-500 hover:bg-amber-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
            }, '← 作品一覧に戻る'),

            React.createElement('button', {
              onClick: onClose,
              className: 'flex-1 bg-gray-500 hover:bg-gray-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
            }, '閉じる')
          )
        )
      );
    };

    // ボス予告画面コンポーネント
    const BattlePreviewDialog = ({ show, boss, playerFood, playerEquipment, onProceed, onEscape }) => {
      if (!show || !boss) return null;

      const getEffectiveAttribute = (bossAttribute) => {
        switch (bossAttribute) {
          case 'fire': return 'water';
          case 'water': return 'wood';
          case 'wood': return 'fire';
          default: return 'fire';
        }
      };

      const getFoodCount = (attribute) => {
        switch (attribute) {
          case 'fire': return playerFood.fire;
          case 'water': return playerFood.water;
          case 'wood': return playerFood.wood;
          default: return 0;
        }
      };

      const effectiveAttribute = getEffectiveAttribute(boss.attribute);

      return React.createElement('div', {
        className: 'fixed inset-0 bg-gradient-to-br from-red-50 to-purple-100 flex items-center justify-center p-4 z-50'
      },
        React.createElement('div', {
          className: 'bg-white rounded-3xl shadow-xl p-8 max-w-md w-full text-center'
        },
          React.createElement('h2', {
            className: 'text-2xl font-bold text-gray-800 mb-6'
          }, '⚔️ ボス出現！'),

          React.createElement('div', {
            className: 'mb-6'
          },
            React.createElement('div', {
              className: 'text-6xl mb-4'
            }, boss.emoji),

            React.createElement('h3', {
              className: 'text-xl font-bold text-gray-800 mb-2'
            }, boss.name),

            React.createElement('p', {
              className: 'text-gray-600 mb-4'
            }, boss.description),

            React.createElement('div', {
              className: 'bg-red-50 border border-red-200 rounded-lg p-4'
            },
              React.createElement('div', {
                className: 'text-sm text-gray-700 mb-2'
              }, `属性: ${boss.attribute === 'fire' ? '🔥 火' : boss.attribute === 'water' ? '💧 水' : '🌿 木'}`),
              React.createElement('div', {
                className: 'text-sm text-gray-700 mb-2'
              }, `HP: ${boss.hp} / 攻撃力: ${boss.attack}`),
              React.createElement('div', {
                className: 'text-sm font-medium text-red-600'
              }, `弱点: ${effectiveAttribute === 'fire' ? '🔥 火' : effectiveAttribute === 'water' ? '💧 水' : '🌿 木'}エサで有利！`)
            )
          ),

          React.createElement('div', {
            className: 'mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg'
          },
            React.createElement('h4', {
              className: 'font-medium text-gray-800 mb-2'
            }, '現在の戦力'),
            React.createElement('div', {
              className: 'text-sm text-gray-600'
            }, `有効エサ(${effectiveAttribute === 'fire' ? '🔥' : effectiveAttribute === 'water' ? '💧' : '🌿'}): ${getFoodCount(effectiveAttribute)}個`),
            React.createElement('div', {
              className: 'text-sm text-gray-600'
            }, `装備防御力: ${playerEquipment}`)
          ),

          React.createElement('div', {
            className: 'space-y-3'
          },
            React.createElement('button', {
              onClick: onProceed,
              className: 'w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
            }, '戦闘準備に進む'),

            React.createElement('button', {
              onClick: onEscape,
              className: 'w-full bg-gray-500 hover:bg-gray-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
            }, '逃げる')
          )
        )
      );
    };

    // 戦闘準備画面コンポーネント
    const BattlePreparationDialog = ({ show, boss, playerFood, playerEquipment, onBattle, onBack }) => {
      if (!show || !boss) return null;

      const getEffectiveAttribute = (bossAttribute) => {
        switch (bossAttribute) {
          case 'fire': return 'water';
          case 'water': return 'wood';
          case 'wood': return 'fire';
          default: return 'fire';
        }
      };

      const getFoodCount = (attribute) => {
        switch (attribute) {
          case 'fire': return playerFood.fire;
          case 'water': return playerFood.water;
          case 'wood': return playerFood.wood;
          default: return 0;
        }
      };

      const calculatePlayerPower = () => {
        const effectiveAttribute = getEffectiveAttribute(boss.attribute);
        const effectiveFoodCount = getFoodCount(effectiveAttribute);
        return {
          hp: effectiveFoodCount,
          attack: Math.floor(effectiveFoodCount * 1.5),
          defense: playerEquipment,
          effectiveAttribute,
          effectiveFoodCount
        };
      };

      const simulateBattle = (playerPower) => {
        const damageReceived = Math.max(0, boss.attack - playerPower.defense);
        const playerSurvives = playerPower.hp > damageReceived;
        const canDefeatBoss = playerPower.attack >= boss.hp;
        return {
          victory: playerSurvives && canDefeatBoss,
          damageReceived,
          playerSurvives,
          canDefeatBoss,
          playerPower,
          boss
        };
      };

      const playerPower = calculatePlayerPower();
      const battleSim = simulateBattle(playerPower);

      return React.createElement('div', {
        className: 'fixed inset-0 bg-gradient-to-br from-blue-50 to-green-100 flex items-center justify-center p-4 z-50'
      },
        React.createElement('div', {
          className: 'bg-white rounded-3xl shadow-xl p-8 max-w-md w-full'
        },
          React.createElement('h2', {
            className: 'text-2xl font-bold text-gray-800 mb-6 text-center'
          }, '⚔️ 戦闘準備'),

          React.createElement('div', {
            className: 'space-y-4'
          },
            React.createElement('div', {
              className: 'p-4 bg-blue-50 border border-blue-200 rounded-lg'
            },
              React.createElement('h3', {
                className: 'font-medium text-gray-800 mb-2'
              }, 'あなたの戦力'),
              React.createElement('div', {
                className: 'text-sm text-gray-600 space-y-1'
              },
                React.createElement('div', {}, `HP: ${playerPower.hp}`),
                React.createElement('div', {}, `攻撃力: ${playerPower.attack}`),
                React.createElement('div', {}, `防御力: ${playerPower.defense}`)
              )
            ),

            React.createElement('div', {
              className: `p-4 border rounded-lg ${battleSim.victory ? 'bg-green-50 border-green-200' : 'bg-red-50 border-red-200'}`
            },
              React.createElement('h3', {
                className: 'font-medium text-gray-800 mb-2'
              }, '戦闘予測'),
              React.createElement('div', {
                className: 'text-sm space-y-1'
              },
                React.createElement('div', {
                  className: battleSim.playerSurvives ? 'text-green-600' : 'text-red-600'
                }, `生存: ${battleSim.playerSurvives ? '✅' : '❌'} (被ダメージ: ${battleSim.damageReceived})`),
                React.createElement('div', {
                  className: battleSim.canDefeatBoss ? 'text-green-600' : 'text-red-600'
                }, `撃破: ${battleSim.canDefeatBoss ? '✅' : '❌'}`),
                React.createElement('div', {
                  className: `font-medium ${battleSim.victory ? 'text-green-600' : 'text-red-600'}`
                }, `結果: ${battleSim.victory ? '勝利' : '敗北'}`)
              )
            ),

            React.createElement('div', {
              className: 'space-y-3'
            },
              React.createElement('button', {
                onClick: () => onBattle(battleSim),
                className: 'w-full bg-red-500 hover:bg-red-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
              }, '戦闘開始！'),

              React.createElement('button', {
                onClick: onBack,
                className: 'w-full bg-gray-500 hover:bg-gray-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
              }, '戻る')
            )
          )
        )
      );
    };

    // 戦闘結果画面コンポーネント
    const BattleResultDialog = ({ show, battleResult, bossName, onClose }) => {
      if (!show || !battleResult) return null;

      return React.createElement('div', {
        className: 'fixed inset-0 bg-gradient-to-br from-yellow-50 to-orange-100 flex items-center justify-center p-4 z-50'
      },
        React.createElement('div', {
          className: 'bg-white rounded-3xl shadow-xl p-8 max-w-md w-full text-center'
        },
          React.createElement('h2', {
            className: 'text-2xl font-bold text-gray-800 mb-6'
          }, battleResult.victory ? '🎉 勝利！' : '💀 敗北...'),

          React.createElement('div', {
            className: 'mb-6'
          },
            React.createElement('div', {
              className: 'text-4xl mb-4'
            }, battleResult.victory ? '👑' : '💀'),

            React.createElement('p', {
              className: 'text-gray-600 mb-4'
            }, battleResult.victory ?
              `${bossName}を見事に倒しました！` :
              `${bossName}に敗れました...`
            ),

            React.createElement('div', {
              className: 'text-sm text-gray-600 space-y-1'
            },
              React.createElement('div', {}, `あなたのHP: ${battleResult.playerPower.hp}`),
              React.createElement('div', {}, `受けたダメージ: ${battleResult.damageReceived}`),
              React.createElement('div', {}, `与えたダメージ: ${battleResult.playerPower.attack}`)
            )
          ),

          React.createElement('div', {
            className: 'space-y-3'
          },
            React.createElement('button', {
              onClick: onClose,
              className: 'w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
            }, '閉じる')
          )
        )
      );
    };

    // 装備ガチャ結果画面コンポーネント
    const EquipmentGachaDialog = ({ show, gachaResult, currentEquipment, onEquip, onKeepCurrent, onDiscard }) => {
      if (!show || !gachaResult) return null;

      const isUpgrade = gachaResult.defense > currentEquipment;

      return React.createElement('div', {
        className: 'fixed inset-0 bg-gradient-to-br from-orange-50 to-yellow-100 flex items-center justify-center p-4 z-50'
      },
        React.createElement('div', {
          className: 'bg-white rounded-3xl shadow-xl p-8 max-w-md w-full text-center'
        },
          React.createElement('h2', {
            className: 'text-2xl font-bold text-gray-800 mb-6'
          }, '🎰 装備ガチャ結果'),

          React.createElement('div', {
            className: 'mb-6'
          },
            React.createElement('div', {
              className: 'text-4xl mb-4'
            }, '⚔️'),

            React.createElement('h3', {
              className: 'text-xl font-bold text-gray-800 mb-2'
            }, gachaResult.name),

            React.createElement('div', {
              className: 'p-4 bg-blue-50 border border-blue-200 rounded-lg mb-4'
            },
              React.createElement('div', {
                className: 'text-sm text-gray-700'
              }, `防御力: +${gachaResult.defense}`),
              React.createElement('div', {
                className: 'text-sm text-gray-600 mt-1'
              }, `使用したエサ: ${gachaResult.usedFoodType === 'fire' ? '🔥' : gachaResult.usedFoodType === 'water' ? '💧' : '🌿'} 1個`)
            ),

            isUpgrade ?
              React.createElement('div', {
                className: 'p-3 bg-green-50 border border-green-200 rounded-lg mb-4'
              },
                React.createElement('p', {
                  className: 'text-green-700 font-medium'
                }, `防御力アップ！ ${currentEquipment} → ${gachaResult.defense}`)
              ) :
              React.createElement('div', {
                className: 'p-3 bg-yellow-50 border border-yellow-200 rounded-lg mb-4'
              },
                React.createElement('p', {
                  className: 'text-yellow-700'
                }, `現在の装備の方が優秀です (現在: ${currentEquipment})`)
              )
          ),

          React.createElement('div', {
            className: 'space-y-3'
          },
            isUpgrade ?
              React.createElement('button', {
                onClick: onEquip,
                className: 'w-full bg-green-500 hover:bg-green-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
              }, '装備する') :
              React.createElement('div', {
                className: 'space-y-2'
              },
                React.createElement('button', {
                  onClick: onEquip,
                  className: 'w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
                }, 'それでも装備する'),
                React.createElement('button', {
                  onClick: onDiscard,
                  className: 'w-full bg-gray-500 hover:bg-gray-600 text-white font-medium py-3 px-6 rounded-xl transition-colors'
                }, '装備しない')
              )
          )
        )
      );
    };

    const AdaptivePomodoro = () => {
      // 基本状態
      const [currentPhase, setCurrentPhase] = useState('idle');
      const [timeLeft, setTimeLeft] = useState(0);
      const [currentWorkDuration, setCurrentWorkDuration] = useState(5);
      const [sessionCount, setSessionCount] = useState(0);

      // ダイアログ制御
      const [showReasonDialog, setShowReasonDialog] = useState(false);
      const [showContinueDialog, setShowContinueDialog] = useState(false);
      const [showBreakSuggestion, setShowBreakSuggestion] = useState(false);
      const [showTaskCompleteDialog, setShowTaskCompleteDialog] = useState(false);

      // タスク情報
      const [reason, setReason] = useState('');
      const [currentTaskReason, setCurrentTaskReason] = useState('');
      const [taskResult, setTaskResult] = useState('');
      const [reasonHistory, setReasonHistory] = useState([]);

      // 統計とゲーミフィケーション
      const [totalWorkTime, setTotalWorkTime] = useState(0);
      const [totalExp, setTotalExp] = useState(0);
      const [level, setLevel] = useState(1);

      // その他の状態
      const [isTimerFinished, setIsTimerFinished] = useState(false);
      const [workStartTime, setWorkStartTime] = useState(null);

      // 新しく追加：やる気モード管理
      const [motivationMode, setMotivationMode] = useState('normal'); // 'normal', 'breathing', 'task-input', 'walk-suggestion'
      const [breathingPhase, setBreathingPhase] = useState('inhale'); // 'inhale', 'hold', 'exhale'
      const [breathingCycle, setBreathingCycle] = useState(0);
      const [passiveTask, setPassiveTask] = useState('');
      const [showPassiveTaskSubmit, setShowPassiveTaskSubmit] = useState(false);

      const [showWorkoutSuggestion, setShowWorkoutSuggestion] = useState(false);
      const [showEquipmentGacha, setShowEquipmentGacha] = useState(false);
      const [gachaResult, setGachaResult] = useState(null);

      // ペット関連の状態
      const [petLevel, setPetLevel] = useState(1);
      const [fireFood, setFireFood] = useState(0);    // 🔥火エサ
      const [waterFood, setWaterFood] = useState(0);  // 💧水エサ
      const [woodFood, setWoodFood] = useState(0);    // 🌿木エサ

      const [petType, setPetType] = useState('egg');
      // 文学システム用ダイアログ
      const [showNewSentenceDialog, setShowNewSentenceDialog] = useState(false);
      const [newlyUnlockedSentence, setNewlyUnlockedSentence] = useState('');

      // 戦闘システム関連の状態
      const [currentBoss, setCurrentBoss] = useState(null);
      const [battlePhase, setBattlePhase] = useState('none'); // 'none', 'preview', 'preparation', 'battle', 'result'
      const [playerEquipment, setPlayerEquipment] = useState(0); // 防御力
      const [battleResult, setBattleResult] = useState(null);

      // 休憩システム関連
      const [isBreakTime, setIsBreakTime] = useState(false);
      const [breakTimeLeft, setBreakTimeLeft] = useState(0);

      // 新しく追加：青空文庫システム用の状態管理
      const [literaryProgress, setLiteraryProgress] = useState({
        currentWork: 'hashire_melos',  // 今読んでいる作品
        currentSentence: 0,            // 今何文目まで読んだか
        completedWorks: [],            // 読み終わった作品のリスト
        totalReadSentences: 0          // 今までに読んだ文の総数
      });
      // 読書記録システム用の状態
      const [showReadingHistory, setShowReadingHistory] = useState(false);
      const [selectedWork, setSelectedWork] = useState(null);

      const intervalRef = useRef(null);
      const breathingIntervalRef = useRef(null);
      const workDurations = [5, 6, 8, 10, 12, 15];

      // 青空文庫の作品データ（最初は走れメロスだけ）
      const literaryWorks = {
        hashire_melos: {
          title: '走れメロス',
          author: '太宰治',
          sentences: [
            "メロスは激怒した。",
            "必ず、かの邪智暴虐の王を除かなければならぬと決意した。",
            "メロスには政治がわからぬ。",
            "メロスは、村の牧人である。",
            "笛を吹き、羊と遊んで暮して来た。"
            // 今はテスト用に5文だけ（後で増やします）
          ],
          totalSentences: 5  // 実際は127文くらいありますが、テスト用に5文
        }
      };

      // 新しい文を解放する関数（修正版）
      const unlockNextSentence = () => {
        setLiteraryProgress(prev => {
          console.log('=== 文解放処理開始 ===');
          console.log('現在のcurrentSentence:', prev.currentSentence);
          console.log('現在のtotalReadSentences:', prev.totalReadSentences);

          const currentWork = literaryWorks[prev.currentWork];
          const nextSentence = prev.currentSentence + 1;

          console.log('計算されたnextSentence:', nextSentence);
          console.log('作品の総文数:', currentWork.sentences.length);

          // まだ読める文があるかチェック
          if (nextSentence < currentWork.sentences.length) {
            console.log(`新しい文解放: ${nextSentence}文目`);
            console.log('解放された文:', currentWork.sentences[nextSentence]);

            // 🆕 新しく追加：ダイアログ表示
            setNewlyUnlockedSentence(currentWork.sentences[nextSentence]);
            setShowNewSentenceDialog(true);

            const newState = {
              ...prev,
              currentSentence: nextSentence,
              totalReadSentences: prev.totalReadSentences + 1
            };

            console.log('新しい状態:', newState);
            console.log('=== 文解放処理終了 ===');
            return newState;
          } else {
            console.log('この作品は全て読み終わりました！');
            console.log('=== 文解放処理終了 ===');
            return prev;
          }
        });
      };

      // ボス情報
      const bossData = [
        {
          id: 'fire_dragon',
          name: '炎のドラゴン',
          emoji: '🐉',
          attribute: 'fire',
          hp: 100,
          attack: 80,
          description: '炎を吐く強力なドラゴン'
        },
        {
          id: 'water_kraken',
          name: '水のクラーケン',
          emoji: '🐙',
          attribute: 'water',
          hp: 120,
          attack: 75,
          description: '深海から現れた巨大な触手の魔物'
        },
        {
          id: 'wood_treant',
          name: '森の番人',
          emoji: '🌳',
          attribute: 'wood',
          hp: 90,
          attack: 85,
          description: '古い森を守る巨大な樹の精霊'
        }
      ];

      // 属性相性オブジェクト
      const attributeEffectiveness = {
        fire: { strongAgainst: 'wood', weakAgainst: 'water' },
        water: { strongAgainst: 'fire', weakAgainst: 'wood' },
        wood: { strongAgainst: 'water', weakAgainst: 'fire' }
      };

      // ローカルストレージから復元
      useEffect(() => {
        loadData();
      }, []);

      // データを保存
      const saveData = () => {
        const data = {
          reasonHistory,
          totalWorkTime,
          totalExp,
          level,
          fireFood,
          waterFood,
          woodFood,
          petLevel,
          playerEquipment
        };
        localStorage.setItem('pomodoroData', JSON.stringify(data));
      };

      // 文学データ専用の保存関数
      const saveLiteraryData = () => {
        const literaryData = {
          literaryProgress
        };
        localStorage.setItem('pomodoroLiteraryData', JSON.stringify(literaryData));
      };

      // 分離された読み込み関数
      const loadData = () => {
        // ゲームデータの読み込み
        const gameData = localStorage.getItem('pomodoroData');
        if (gameData) {
          try {
            const data = JSON.parse(gameData);
            setReasonHistory(data.reasonHistory || []);
            setTotalWorkTime(data.totalWorkTime || 0);
            setTotalExp(data.totalExp || 0);
            setLevel(data.level || 1);
            setFireFood(data.fireFood || 0);
            setWaterFood(data.waterFood || 0);
            setWoodFood(data.woodFood || 0);
            setPetLevel(data.petLevel || 1);
            setPlayerEquipment(data.playerEquipment || 0);
          } catch (e) {
            console.log('ゲームデータの読み込みに失敗しました');
          }
        }

        // 文学データの読み込み
        const literaryData = localStorage.getItem('pomodoroLiteraryData');
        if (literaryData) {
          try {
            const data = JSON.parse(literaryData);
            setLiteraryProgress(data.literaryProgress || {
              currentWork: 'hashire_melos',
              currentSentence: 0,
              completedWorks: [],
              totalReadSentences: 0
            });
          } catch (e) {
            console.log('文学データの読み込みに失敗しました');
          }
        }
      };

      useEffect(() => {
        saveData();
      }, [reasonHistory, totalWorkTime, totalExp, level, fireFood, waterFood, woodFood, petLevel, playerEquipment]
      );

      // 文学データの自動保存
      useEffect(() => {
        saveLiteraryData();
      }, [literaryProgress]);

      // 呼吸ガイド機能
      useEffect(() => {
        if (motivationMode === 'breathing') {
          breathingIntervalRef.current = setInterval(() => {
            setBreathingPhase(prev => {
              if (prev === 'inhale') return 'hold';
              if (prev === 'hold') return 'exhale';
              if (prev === 'exhale') {
                setBreathingCycle(cycle => {
                  const newCycle = cycle + 1;
                  if (newCycle >= 5) {
                    // 5サイクル完了
                    setMotivationMode('choice');
                    return 0;
                  }
                  return newCycle;
                });
                return 'inhale';
              }
              return 'inhale';
            });
          }, breathingPhase === 'inhale' ? 4000 : breathingPhase === 'hold' ? 7000 : 8000);
        } else {
          if (breathingIntervalRef.current) {
            clearInterval(breathingIntervalRef.current);
          }
        }

        return () => {
          if (breathingIntervalRef.current) {
            clearInterval(breathingIntervalRef.current);
          }
        };
      }, [motivationMode, breathingPhase]);

      useEffect(() => {
        if (currentPhase === 'work') {
          console.log('🔥 作業タイマー開始！時間:', timeLeft, '秒');
          intervalRef.current = setInterval(() => {
            setTimeLeft(prev => {
              console.log('⏱️ タイマー更新:', prev, '→', prev - 1);
              if (prev <= 1) {
                setCurrentPhase('continue-check');
                setShowContinueDialog(true);
                setIsTimerFinished(true);
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        } else {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
          }
        }

        return () => {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
          }
        };
      }, [currentPhase]);

      // 休憩タイマー
      useEffect(() => {
        if (isBreakTime) {
          intervalRef.current = setInterval(() => {
            setBreakTimeLeft(prev => {
              console.log('🔍 休憩タイマー:', prev, '秒残り');
              if (prev <= 1) {
                console.log('🎯 休憩終了！次のセッション準備開始');
                console.log('📊 現在のsessionCount:', sessionCount);
                console.log('📋 workDurations配列:', workDurations);
                console.log('🔢 workDurations.length:', workDurations.length);

                setIsBreakTime(false);

                // 休憩終了後、次のワークセッション開始
                if (sessionCount < workDurations.length) {
                  const nextDuration = workDurations[sessionCount];
                  console.log('🚀 状態変更前 - currentPhase:', currentPhase, 'timeLeft:', timeLeft);

                  // 状態を確実に更新するため、まとめて処理
                  const newTimeLeft = nextDuration * 60;
                  console.log('🚀 設定予定 - nextDuration:', nextDuration, 'newTimeLeft:', newTimeLeft);

                  setCurrentWorkDuration(nextDuration);
                  setTimeLeft(newTimeLeft);
                  setCurrentPhase('work');
                  setWorkStartTime(Date.now());

                  // 強制的に次のレンダリングサイクルで確認
                  setTimeout(() => {
                    console.log('🔍 nextTick後の状態確認');
                    // 強制的にタイマー開始
                    if (intervalRef.current) {
                      clearInterval(intervalRef.current);
                    }
                    intervalRef.current = setInterval(() => {
                      setTimeLeft(prev => {
                        console.log('⏱️ 強制タイマー更新:', prev, '→', prev - 1);
                        if (prev <= 1) {
                          setCurrentPhase('continue-check');
                          setShowContinueDialog(true);
                          setIsTimerFinished(true);
                          return 0;
                        }
                        return prev - 1;
                      });
                    }, 1000);
                  }, 50);

                  // 作業開始時刻をすぐに設定
                  setWorkStartTime(Date.now());
                } else {
                  console.log('🏁 全セッション完了！');
                  setCurrentPhase('completed');
                }
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        } else {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
          }
        }

        return () => {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
          }
        };
      }, [isBreakTime, sessionCount]);

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const getRandomFood = () => {
        const foods = ['fire', 'water', 'wood'];
        return foods[Math.floor(Math.random() * 3)];
      };

      // 戦闘システム関数
      const getFoodCount = (attribute) => {
        switch (attribute) {
          case 'fire': return fireFood;
          case 'water': return waterFood;
          case 'wood': return woodFood;
          default: return 0;
        }
      };

      const getEffectiveAttribute = (bossAttribute) => {
        switch (bossAttribute) {
          case 'fire': return 'water';    // 火には水が有効
          case 'water': return 'wood';    // 水には木が有効  
          case 'wood': return 'fire';     // 木には火が有効
          default: return 'fire';
        }
      };

      const calculatePlayerPower = (boss) => {
        const effectiveAttribute = getEffectiveAttribute(boss.attribute);
        const effectiveFoodCount = getFoodCount(effectiveAttribute);

        return {
          hp: effectiveFoodCount,
          attack: Math.floor(effectiveFoodCount * 1.5), // 有利属性ボーナス
          defense: playerEquipment,
          effectiveAttribute,
          effectiveFoodCount
        };
      };

      const simulateBattle = (playerPower, boss) => {
        // 敵の攻撃でプレイヤーが受けるダメージ
        const damageReceived = Math.max(0, boss.attack - playerPower.defense);
        const playerSurvives = playerPower.hp > damageReceived;

        // プレイヤーが敵を一撃で倒せるか
        const canDefeatBoss = playerPower.attack >= boss.hp;

        return {
          victory: playerSurvives && canDefeatBoss,
          damageReceived,
          playerSurvives,
          canDefeatBoss,
          playerPower,
          boss
        };
      };

      const rollEquipmentGacha = (foodCost = 1) => {
        const baseDefense = Math.floor(Math.random() * 11) + 5; // 5-15
        const equipmentNames = ['鋼の盾', '魔法の鎧', '竜鱗の盾', '聖なる外套', '古の守護具'];
        const randomName = equipmentNames[Math.floor(Math.random() * equipmentNames.length)];

        return {
          name: `${randomName} +${baseDefense}`,
          defense: baseDefense,
          cost: foodCost
        };
      };
      const executeEquipmentGacha = () => {
        // 現在のボス戦で有効でない属性のエサを特定
        // ボスがいない場合は、どのエサでも消費可能
        let availableFoodTypes = [];

        if (currentBoss) {
          const effectiveAttribute = getEffectiveAttribute(currentBoss.attribute);
          // 有効属性以外のエサを対象にする
          if (effectiveAttribute !== 'fire' && fireFood > 0) availableFoodTypes.push('fire');
          if (effectiveAttribute !== 'water' && waterFood > 0) availableFoodTypes.push('water');
          if (effectiveAttribute !== 'wood' && woodFood > 0) availableFoodTypes.push('wood');
        } else {
          // ボスがいない場合は全てのエサが使用可能
          if (fireFood > 0) availableFoodTypes.push('fire');
          if (waterFood > 0) availableFoodTypes.push('water');
          if (woodFood > 0) availableFoodTypes.push('wood');
        }

        if (availableFoodTypes.length === 0) return; // 使用可能なエサがない

        // ランダムに1つ選択（複数ある場合）
        const selectedFoodType = availableFoodTypes[Math.floor(Math.random() * availableFoodTypes.length)];

        // エサを1個消費
        if (selectedFoodType === 'fire') setFireFood(prev => prev - 1);
        if (selectedFoodType === 'water') setWaterFood(prev => prev - 1);
        if (selectedFoodType === 'wood') setWoodFood(prev => prev - 1);

        // ガチャ実行
        const result = rollEquipmentGacha(1);
        result.usedFoodType = selectedFoodType;
        setGachaResult(result);
      };

      const spawnRandomBoss = () => {
        const randomBoss = bossData[Math.floor(Math.random() * bossData.length)];
        setCurrentBoss({ ...randomBoss });
        setBattlePhase('preview');
      };

      const startWork = () => {
        setShowReasonDialog(true);
        setCurrentPhase('work');
        setTimeLeft(currentWorkDuration * 60);
        setWorkStartTime(Date.now());
      };

      const startBreathing = () => {
        setMotivationMode('breathing');
        setBreathingCycle(0);
        setBreathingPhase('inhale');
      };

      const handlePassiveTaskSubmit = () => {
        if (passiveTask.trim()) {
          setShowPassiveTaskSubmit(true);
        }
      };

      const handlePassiveTaskStart = () => {
        setMotivationMode('normal');
        setCurrentWorkDuration(5);
        setShowPassiveTaskSubmit(false);
        setReason(passiveTask);
        setPassiveTask('');
        startWork();
      };

      const handleWalkSuggestion = () => {
        setMotivationMode('walk-suggestion');
        setShowPassiveTaskSubmit(false);
      };

      const handleReturnFromWalk = () => {
        setMotivationMode('task-input');
      };

      const handleWorkoutSuggestion = () => {
        setMotivationMode('workout-suggestion');
        setShowPassiveTaskSubmit(false);
      };

      const handleReturnFromWorkout = () => {
        setMotivationMode('task-input');
      };

      const resetMotivationMode = () => {
        setMotivationMode('normal');
        setBreathingCycle(0);
        setBreathingPhase('inhale');
        setPassiveTask('');
        setShowPassiveTaskSubmit(false);
      };

      const getBreathingCircleSize = () => {
        if (breathingPhase === 'inhale') return 'w-32 h-32 scale-110';
        if (breathingPhase === 'hold') return 'w-32 h-32 scale-110';
        if (breathingPhase === 'exhale') return 'w-20 h-20 scale-90';
        return 'w-24 h-24';
      };

      const getBreathingText = () => {
        if (breathingPhase === 'inhale') return '息を吸って';
        if (breathingPhase === 'hold') return '止めて';
        if (breathingPhase === 'exhale') return '息を吐いて';
        return '';
      };

      const handleReasonSubmit = () => {
        if (reason.trim()) {
          setCurrentTaskReason(reason.trim());
          setReason('');
        }
        setShowReasonDialog(false);
      };


      const handleTaskComplete = () => {
        const actualWorkTime = Math.ceil((Date.now() - workStartTime) / 60000);
        const expGained = Math.ceil(actualWorkTime * 1.5);

        const now = new Date();
        setReasonHistory(prev => [...prev, {
          reason: currentTaskReason,
          result: taskResult.trim() || '作業完了',
          datetime: now.toLocaleString('ja-JP'),
          plannedDuration: currentWorkDuration,
          actualDuration: actualWorkTime,
          expGained
        }]);

        setTotalWorkTime(prev => prev + actualWorkTime);
        setTotalExp(prev => {
          const newExp = prev + expGained;
          const newLevel = Math.floor(newExp / 100) + 1;
          setLevel(newLevel);
          return newExp;
          // 文学システム：新しい文を解放
          unlockNextSentence();
        });
        // エサ獲得処理
        const foodType = getRandomFood();
        if (foodType === 'fire') setFireFood(prev => prev + 1);
        if (foodType === 'water') setWaterFood(prev => prev + 1);
        if (foodType === 'wood') setWoodFood(prev => prev + 1);
        // 文学システム：新しい文を解放
        unlockNextSentence();

        // 状態をリセット
        setShowTaskCompleteDialog(false);
        setCurrentPhase('idle');
        setCurrentTaskReason('');
        setTaskResult('');
        setSessionCount(0);
        setCurrentWorkDuration(5);
        setTimeLeft(0);
        setWorkStartTime(null);
        setIsTimerFinished(false);
      };

      const handleEarlyComplete = () => {
        if (intervalRef.current) {
          clearInterval(intervalRef.current);
        }
        // 文学システム：新しい文を解放
        unlockNextSentence();
        setCurrentPhase('task-complete');
        setShowTaskCompleteDialog(true);
      };
      const handleContinue = () => {
        console.log('=== 続けるボタン処理開始 ===');

        setShowContinueDialog(false);
        setIsTimerFinished(false);
        setSessionCount(prev => prev + 1);

        // エサ獲得処理
        const foodType = getRandomFood();
        if (foodType === 'fire') setFireFood(prev => prev + 1);
        if (foodType === 'water') setWaterFood(prev => prev + 1);
        if (foodType === 'wood') setWoodFood(prev => prev + 1);

        // 文学システム：新しい文を解放
        unlockNextSentence();

        const currentActualTime = Math.ceil((Date.now() - workStartTime) / 60000);
        if (currentActualTime >= 56) {
          setCurrentPhase('completed');
          return;
        }

        const nextSessionIndex = sessionCount + 1;

        // デバッグ情報を追加
        console.log('現在のsessionCount:', sessionCount);
        console.log('nextSessionIndex:', nextSessionIndex);
        console.log('workDurations.length:', workDurations.length);
        console.log('条件チェック:', nextSessionIndex < workDurations.length);

        if (nextSessionIndex < workDurations.length) {
          console.log('✅ 条件OK、次のセッション開始');
          setCurrentWorkDuration(workDurations[nextSessionIndex]);
          setCurrentPhase('work');
          setTimeLeft(workDurations[nextSessionIndex] * 60);
          setWorkStartTime(Date.now());
          console.log('次の作業時間:', workDurations[nextSessionIndex], '分');

          // 追加：強制的にタイマー開始（休憩終了時と同じ処理）
          setTimeout(() => {
            console.log('🔧 強制タイマー開始処理');
            if (intervalRef.current) {
              clearInterval(intervalRef.current);
            }
            intervalRef.current = setInterval(() => {
              setTimeLeft(prev => {
                console.log('⏱️ 強制タイマー更新:', prev, '→', prev - 1);
                if (prev <= 1) {
                  setCurrentPhase('continue-check');
                  setShowContinueDialog(true);
                  setIsTimerFinished(true);
                  return 0;
                }
                return prev - 1;
              });
            }, 1000);
          }, 50);

        } else {
          console.log('❌ 全セッション完了、次のセッションなし');
        }
      };

      const handleStop = () => {
        setShowContinueDialog(false);
        setIsTimerFinished(false);

        if (sessionCount === 0) {
          setShowBreakSuggestion(true);
        } else {
          setShowTaskCompleteDialog(true);
        }
      };

      const handleBreakSuggestion = (action) => {
        setShowBreakSuggestion(false);
        if (action === 'retry') {
          setCurrentPhase('work');
          setTimeLeft(5 * 60);
        } else {
          setCurrentPhase('idle');
        }
      };

      const reset = () => {
        setCurrentPhase('idle');
        setTimeLeft(0);
        setCurrentWorkDuration(5);
        setSessionCount(0);
        setTotalWorkTime(0);
        setReasonHistory([]);
        setShowReasonDialog(false);
        setShowContinueDialog(false);
        setShowBreakSuggestion(false);
        setShowTaskCompleteDialog(false);
        setCurrentTaskReason('');
        setTaskResult('');
        setIsTimerFinished(false);
        setWorkStartTime(null);
        saveData();
      };

      const getPhaseDisplay = () => {
        if (isBreakTime) {
          return '休憩中 (5分)';
        }

        switch (currentPhase) {
          case 'work':
            return `作業中 (${currentWorkDuration}分)`;
          case 'continue-check':
            return '継続確認';
          case 'completed':
            return 'セッション完了！';
          default:
            return '待機中';
        }
      };

      return React.createElement('div', {
        className: `min-h-screen bg-gray-50 py-8 px-4`
      },
        React.createElement('div', {
          className: `max-w-md mx-auto p-6 rounded-lg shadow-lg transition-all duration-500 ${isTimerFinished ? 'bg-green-100 border-4 border-green-400 animate-pulse' : 'bg-white'
            }`
        },
          React.createElement('h1', {
            className: 'text-2xl font-bold text-gray-800 mb-6 text-center'
          }, '適応型ポモドーロタイマー'),

          React.createElement('div', {
            className: 'text-center mb-6'
          },
            React.createElement('div', {
              className: 'text-lg font-medium text-gray-600 mb-2'
            }, getPhaseDisplay()),
            React.createElement('div', {
              className: 'text-4xl font-mono font-bold text-gray-800'
            }, formatTime(isBreakTime ? breakTimeLeft : timeLeft)),

            currentTaskReason && currentPhase === 'work' && React.createElement('div', {
              className: 'mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg'
            },
              React.createElement('div', {
                className: 'text-sm text-gray-600 mb-1'
              }, '現在のタスク:'),
              React.createElement('div', {
                className: 'text-sm font-medium text-gray-800'
              }, currentTaskReason)
            )
          ),

          // レベルと経験値表示
          React.createElement('div', {
            className: 'mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg'
          },
            React.createElement('div', {
              className: 'flex justify-between items-center mb-2'
            },
              React.createElement('span', {
                className: 'text-sm font-medium text-blue-800'
              }, `Lv.${level}`),
              React.createElement('span', {
                className: 'text-sm text-blue-600'
              }, `${totalExp % 100}/100 EXP`)
            ),
            React.createElement('div', {
              className: 'w-full bg-blue-200 rounded-full h-2'
            },
              React.createElement('div', {
                className: 'bg-blue-600 h-2 rounded-full transition-all duration-300',
                style: { width: `${(totalExp % 100)}%` }
              })
            ),
            React.createElement('div', {
              className: 'text-xs text-blue-600 mt-1'
            }, `累計作業時間: ${totalWorkTime}分 | 総経験値: ${totalExp}`)
          ),

          // ペット表示エリア
          React.createElement('div', {
            className: 'mb-4 p-3 bg-green-50 border border-green-200 rounded-lg'
          },
            React.createElement('div', {
              className: 'text-center mb-2'
            },
              React.createElement('div', {
                className: 'text-4xl mb-1'
              }, petType === 'egg' ? '🥚' : petType === 'cat' ? '🐱' : '🐉'),
              React.createElement('div', {
                className: 'text-sm font-medium text-green-800'
              }, `ペットLv.${petLevel}`)
            ),
            React.createElement('div', {
              className: 'text-xs text-green-600 text-center'
            }, `🔥${fireFood} 💧${waterFood} 🌿${woodFood}`)
          ),

          React.createElement('div', {
            className: 'mb-6'
          },
            React.createElement('div', {
              className: 'text-sm text-gray-600 mb-2'
            }, `セッション: ${sessionCount + 1}/6`),
            React.createElement('div', {
              className: 'w-full bg-gray-200 rounded-full h-2'
            },
              React.createElement('div', {
                className: 'bg-green-600 h-2 rounded-full transition-all duration-300',
                style: { width: `${((sessionCount + 1) / 6) * 100}%` }
              })
            )
          ),

          React.createElement('div', {
            className: 'space-y-4'
          },
            currentPhase === 'work' && React.createElement('button', {
              onClick: handleEarlyComplete,
              className: 'w-full py-3 px-4 bg-green-500 text-white rounded-lg font-medium hover:bg-green-600 transition-colors mb-4'
            }, 'タスク終了'),

            currentPhase === 'idle' && motivationMode === 'normal' && React.createElement('div', {
              className: 'space-y-6'
            },
              // 🔧 デバッグボタン領域
              React.createElement('div', {
                className: 'space-y-2'
              },
                React.createElement('div', {
                  className: 'text-xs text-gray-500 font-medium mb-2 text-center border-b border-gray-200 pb-1'
                }, '🔧 デバッグ'),

                React.createElement('button', {
                  onClick: () => {
                    if (isBreakTime) {
                      setBreakTimeLeft(1);
                    } else {
                      setTimeLeft(1);
                    }
                  },
                  className: 'w-full py-2 px-4 bg-yellow-500 text-white rounded-lg font-medium hover:bg-yellow-600 transition-colors text-sm'
                }, '⚡ タイマースキップ'),

                React.createElement('button', {
                  onClick: () => {
                    if (confirm('ゲームデータ（レベル・エサ・装備等）を削除しますか？')) {
                      localStorage.removeItem('pomodoroData');
                      setReasonHistory([]);
                      setTotalWorkTime(0);
                      setTotalExp(0);
                      setLevel(1);
                      setFireFood(0);
                      setWaterFood(0);
                      setWoodFood(0);
                      setPetLevel(1);
                      setPlayerEquipment(0);
                    }
                  },
                  className: 'w-full py-2 px-4 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors text-sm'
                }, '🎮 ゲームデータ削除')
              ),

              // 🎯 タイマーボタン領域
              React.createElement('div', {
                className: 'space-y-2'
              },
                React.createElement('div', {
                  className: 'text-xs text-gray-500 font-medium mb-2 text-center border-b border-gray-200 pb-1'
                }, '🎯 作業開始'),

                React.createElement('button', {
                  onClick: startWork,
                  className: 'w-full py-3 px-4 bg-red-500 text-white rounded-lg font-medium hover:bg-red-600 transition-colors'
                }, '嫌だなボタン'),

                React.createElement('button', {
                  onClick: startBreathing,
                  className: 'w-full py-3 px-4 bg-gray-400 text-white rounded-lg font-medium hover:bg-gray-500 transition-colors'
                }, '何のやる気も出ない')
              ),

              // 🎮 ゲームボタン領域
              React.createElement('div', {
                className: 'space-y-2'
              },
                React.createElement('div', {
                  className: 'text-xs text-gray-500 font-medium mb-2 text-center border-b border-gray-200 pb-1'
                }, '🎮 ゲーム'),

                React.createElement('button', {
                  onClick: spawnRandomBoss,
                  className: 'w-full py-3 px-4 bg-purple-600 text-white rounded-lg font-medium hover:bg-purple-700 transition-colors'
                }, '⚔️ ボス戦に挑戦'),

                React.createElement('button', {
                  onClick: () => {
                    executeEquipmentGacha();
                    setShowEquipmentGacha(true);
                  },
                  disabled: (() => {
                    if (currentBoss) {
                      const effectiveAttribute = getEffectiveAttribute(currentBoss.attribute);
                      return (effectiveAttribute !== 'fire' ? fireFood : 0) +
                        (effectiveAttribute !== 'water' ? waterFood : 0) +
                        (effectiveAttribute !== 'wood' ? woodFood : 0) === 0;
                    } else {
                      return fireFood === 0 && waterFood === 0 && woodFood === 0;
                    }
                  })(),
                  className: `w-full py-3 px-4 ${(() => {
                    if (currentBoss) {
                      const effectiveAttribute = getEffectiveAttribute(currentBoss.attribute);
                      const hasUsableFood = (effectiveAttribute !== 'fire' ? fireFood : 0) +
                        (effectiveAttribute !== 'water' ? waterFood : 0) +
                        (effectiveAttribute !== 'wood' ? woodFood : 0) > 0;
                      return hasUsableFood ? 'bg-orange-500 hover:bg-orange-600' : 'bg-gray-300';
                    } else {
                      return (fireFood > 0 || waterFood > 0 || woodFood > 0) ? 'bg-orange-500 hover:bg-orange-600' : 'bg-gray-300';
                    }
                  })()} text-white rounded-lg font-medium transition-colors`
                }, `🎰 装備ガチャ (エサ1個消費)`),

                React.createElement('button', {
                  onClick: () => setShowReadingHistory(true),
                  className: 'w-full py-3 px-4 bg-indigo-500 text-white rounded-lg font-medium hover:bg-indigo-600 transition-colors'
                }, '📚 読書記録')
              )
            ),


            // ボス予告画面（置き換え後）
            React.createElement(BattlePreviewDialog, {
              show: battlePhase === 'preview',
              boss: currentBoss,
              playerFood: { fire: fireFood, water: waterFood, wood: woodFood },
              playerEquipment: playerEquipment,
              onProceed: () => setBattlePhase('preparation'),
              onEscape: () => setBattlePhase('none')
            }),

            // 戦闘準備画面（置き換え後）
            React.createElement(BattlePreparationDialog, {
              show: battlePhase === 'preparation',
              boss: currentBoss,
              playerFood: { fire: fireFood, water: waterFood, wood: woodFood },
              playerEquipment: playerEquipment,
              onBattle: (battleSim) => {
                setBattleResult(battleSim);
                setBattlePhase('result');
              },
              onBack: () => setBattlePhase('preview')
            }),

            // 戦闘結果画面（置き換え後）
            React.createElement(BattleResultDialog, {
              show: battlePhase === 'result',
              battleResult: battleResult,
              bossName: currentBoss?.name || '',
              onClose: () => {
                setBattlePhase('none');
                setCurrentBoss(null);
                setBattleResult(null);
              }
            }),

            // 装備ガチャ結果画面（置き換え後）
            React.createElement(EquipmentGachaDialog, {
              show: showEquipmentGacha,
              gachaResult: gachaResult,
              currentEquipment: playerEquipment,
              onEquip: () => {
                setPlayerEquipment(gachaResult.defense);
                setShowEquipmentGacha(false);
                setGachaResult(null);
              },
              onKeepCurrent: () => {
                setPlayerEquipment(gachaResult.defense);
                setShowEquipmentGacha(false);
                setGachaResult(null);
              },
              onDiscard: () => {
                setShowEquipmentGacha(false);
                setGachaResult(null);
              }
            }),

            // 新しい文解放ダイアログ（置き換え後）
            React.createElement(NewSentenceDialog, {
              show: showNewSentenceDialog,
              sentence: newlyUnlockedSentence,
              onClose: () => {
                setShowNewSentenceDialog(false);
                setNewlyUnlockedSentence('');
              }
            }),

            // 読書記録画面（置き換え後）
            React.createElement(ReadingHistoryDialog, {
              show: showReadingHistory,
              literaryProgress: literaryProgress,
              literaryWorks: literaryWorks,
              onClose: () => setShowReadingHistory(false),
              onSelectWork: (work) => setSelectedWork(work),
              onDeleteData: () => {
                if (confirm('読書データ（文学進捗）を削除しますか？この操作は取り消せません。')) {
                  localStorage.removeItem('pomodoroLiteraryData');
                  setLiteraryProgress({
                    currentWork: 'hashire_melos',
                    currentSentence: 0,
                    completedWorks: [],
                    totalReadSentences: 0
                  });
                  setShowReadingHistory(false);
                }
              }
            }),

            // 作品読書画面（置き換え後）
            React.createElement(WorkReadingDialog, {
              show: !!selectedWork,
              selectedWork: selectedWork,
              literaryWorks: literaryWorks,
              literaryProgress: literaryProgress,
              onBack: () => setSelectedWork(null),
              onClose: () => {
                setSelectedWork(null);
                setShowReadingHistory(false);
              }
            }),

            currentPhase === 'completed' && React.createElement('div', {
              className: 'text-center'
            },
              React.createElement('p', {
                className: 'text-green-600 font-medium mb-4'
              }, 'お疲れさまでした！約1時間の作業を完了しました。'),
              React.createElement('button', {
                onClick: reset,
                className: 'py-2 px-4 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors'
              }, 'リセット')
            ),

            reasonHistory.length > 0 && React.createElement('div', {
              className: 'mt-6'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium text-gray-800 mb-3'
              }, '記録'),
              React.createElement('div', {
                className: 'space-y-2 max-h-40 overflow-y-auto'
              },
                reasonHistory.map((entry, index) =>
                  React.createElement('div', {
                    key: index,
                    className: 'p-3 bg-gray-50 rounded text-sm border-l-4 border-blue-400'
                  },
                    React.createElement('div', {
                      className: 'font-medium text-gray-800 mb-1'
                    }, entry.datetime),
                    React.createElement('div', {
                      className: 'text-gray-600 mb-1'
                    },
                      React.createElement('span', {
                        className: 'font-medium'
                      }, '課題: '),
                      entry.reason
                    ),
                    React.createElement('div', {
                      className: 'text-gray-600 mb-1'
                    },
                      React.createElement('span', {
                        className: 'font-medium'
                      }, '結果: '),
                      entry.result
                    ),
                    React.createElement('div', {
                      className: 'flex justify-between text-xs text-gray-500'
                    },
                      React.createElement('span', {}, `予定: ${entry.plannedDuration}分 / 実際: ${entry.actualDuration}分`),
                      React.createElement('span', {
                        className: 'text-blue-600 font-medium'
                      }, `+${entry.expGained} EXP`)
                    )
                  )
                )
              )
            )
          ),

          // 理由入力ダイアログ
          showReasonDialog && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-4'
              }, '何が嫌でしたか？'),
              React.createElement('textarea', {
                value: reason,
                onChange: (e) => setReason(e.target.value),
                className: 'w-full p-3 border border-gray-300 rounded-lg mb-4 resize-none',
                rows: 3,
                placeholder: '例：レポートを書かなければならない...'
              }),
              React.createElement('div', {
                className: 'flex space-x-2'
              },
                React.createElement('button', {
                  onClick: handleReasonSubmit,
                  className: 'flex-1 py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors'
                }, '開始')
              ),
              React.createElement('div', {
                className: 'mt-2 text-xs text-gray-500 text-center'
              }, `タイマーは既に開始されています (${currentWorkDuration}分)`)
            )
          ),

          // 継続確認ダイアログ
          showContinueDialog && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full text-center'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-4'
              }, `${currentWorkDuration}分お疲れさまでした！`),
              React.createElement('div', {
                className: 'mb-6'
              },
                React.createElement('p', {
                  className: 'text-sm text-gray-600 mb-2'
                }, `次は${sessionCount + 1 < workDurations.length ? workDurations[sessionCount + 1] : 15}分の作業になります`),
                React.createElement('p', {
                  className: 'text-sm text-gray-600'
                }, '続けられそうですか？（休憩なしで即座に開始）')
              ),
              React.createElement('div', {
                className: 'flex space-x-2'
              },
                React.createElement('button', {
                  onClick: handleContinue,
                  className: 'flex-1 py-2 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors'
                }, '続ける'),
                React.createElement('button', {
                  onClick: () => {
                    setShowContinueDialog(false);
                    setIsTimerFinished(false);
                    setSessionCount(prev => prev + 1);
                    // セッション完了でエサ獲得
                    const foodType = getRandomFood();
                    if (foodType === 'fire') setFireFood(prev => prev + 1);
                    if (foodType === 'water') setWaterFood(prev => prev + 1);
                    if (foodType === 'wood') setWoodFood(prev => prev + 1);
                    // 文学システム：新しい文を解放
                    unlockNextSentence();
                    setIsBreakTime(true);
                    setBreakTimeLeft(5 * 60); // 5分休憩
                  },

                  className: 'flex-1 py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors'
                }, '5分休憩'),
                React.createElement('button', {
                  onClick: handleStop,
                  className: 'flex-1 py-2 px-4 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors'
                }, '終了')
              )
            )
          ),

          // タスク分解提案ダイアログ
          showBreakSuggestion && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-4'
              }, 'タスクを分解してみましょう'),
              React.createElement('div', {
                className: 'text-sm text-gray-600 mb-4'
              },
                React.createElement('p', {
                  className: 'mb-2'
                }, '5分も集中できなかった場合は、タスクをより小さく分けると良いかもしれません：'),
                React.createElement('ul', {
                  className: 'list-disc list-inside space-y-1'
                },
                  React.createElement('li', {}, '資料を1ページだけ読む'),
                  React.createElement('li', {}, 'ファイルを開いてタイトルだけ書く'),
                  React.createElement('li', {}, '関連する道具や資料を机に並べる'),
                  React.createElement('li', {}, '5行だけメモを書く'),
                  React.createElement('li', {}, '1つの段落だけ読む')
                )
              ),
              React.createElement('div', {
                className: 'flex space-x-2'
              },
                React.createElement('button', {
                  onClick: () => handleBreakSuggestion('retry'),
                  className: 'flex-1 py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors text-sm'
                }, 'もう一度5分'),
                React.createElement('button', {
                  onClick: () => handleBreakSuggestion('stop'),
                  className: 'flex-1 py-2 px-4 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors text-sm'
                }, '今日は終了')
              )
            )
          ),
          // 呼吸ガイドダイアログ
          motivationMode === 'breathing' && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full text-center'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-4'
              }, '深呼吸をしてみましょう'),

              React.createElement('div', {
                className: 'flex justify-center mb-6'
              },
                React.createElement('div', {
                  className: `rounded-full bg-blue-300 transition-all duration-1000 ${getBreathingCircleSize()}`
                })
              ),

              React.createElement('div', {
                className: 'text-xl font-medium text-blue-600 mb-4'
              }, getBreathingText()),

              React.createElement('div', {
                className: 'text-sm text-gray-600 mb-4'
              }, `${breathingCycle + 1}/5 回目`),

              
              React.createElement('div', {
                className: 'space-y-2'
              },
                React.createElement('button', {
                  onClick: () => setBreathingCycle(4),
                  className: 'w-full py-2 px-4 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors text-sm'
                }, '🫁 スキップ'),

                React.createElement('button', {
                  onClick: resetMotivationMode,
                  className: 'w-full py-2 px-4 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors'
                }, 'キャンセル')
              )
            )
          ),

          // タスク入力ダイアログ
          motivationMode === 'task-input' && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-4'
              }, '小さなタスクを入力してください'),

              React.createElement('textarea', {
                value: passiveTask,
                onChange: (e) => setPassiveTask(e.target.value),
                className: 'w-full p-3 border border-gray-300 rounded-lg resize-none',
                rows: 3,
                placeholder: '例：机の上を整理する、メールを1通返信する...'
              }),

              React.createElement('div', {
                className: 'space-y-2 mt-4'
              },
                React.createElement('button', {
                  onClick: handlePassiveTaskSubmit,
                  disabled: !passiveTask.trim(),
                  className: `w-full py-3 px-4 ${passiveTask.trim() ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-300'} text-white rounded-lg font-medium transition-colors`
                }, '5分だけやってみる'),

                React.createElement('button', {
                  onClick: resetMotivationMode,
                  className: 'w-full py-2 px-4 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors'
                }, '戻る')
              )
            )
          ),
          // 選択肢ダイアログ（深呼吸完了後）
          motivationMode === 'choice' && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full text-center'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-6'
              }, 'どうしますか？'),

              React.createElement('div', {
                className: 'space-y-3'
              },
                React.createElement('button', {
                  onClick: () => setShowReasonDialog(true),
                  className: 'w-full py-3 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors'
                }, '5分だけやってみる'),

                React.createElement('button', {
                  onClick: () => setMotivationMode('workout'),
                  className: 'w-full py-3 px-4 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition-colors'
                }, '筋トレする'),

                React.createElement('button', {
                  onClick: () => setMotivationMode('walk'),
                  className: 'w-full py-3 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors'
                }, '散歩する')
              )
            )
          ),

          // 筋トレ画面
          motivationMode === 'workout' && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full text-center'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-4'
              }, '💪 HIITタイマーを起動してください'),

              React.createElement('div', {
                className: 'mb-6 p-4 bg-orange-50 border border-orange-200 rounded-lg'
              },
                React.createElement('p', {
                  className: 'text-sm text-gray-700'
                }, '別のアプリでHIITタイマーを起動して、筋トレを行ってください。完了したら下のボタンを押してください。')
              ),

              React.createElement('button', {
                onClick: () => {
                  setMotivationMode('normal');  // ダイアログを閉じる
                  setShowReasonDialog(true);    // タスク入力ダイアログを開く
                },
                className: 'w-full py-3 px-4 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition-colors'
              }, '筋トレ完了')
            )
          ),

          // 散歩画面
          motivationMode === 'walk' && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full text-center'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-4'
              }, '🚶‍♂️ 10分程度の散歩をしてきてください'),

              React.createElement('div', {
                className: 'mb-6 p-4 bg-green-50 border border-green-200 rounded-lg'
              },
                React.createElement('p', {
                  className: 'text-sm text-gray-700'
                }, '外の空気を吸って、軽く歩いてリフレッシュしてきてください。戻ったら下のボタンを押してください。')
              ),

              React.createElement('button', {
                onClick: () => {
                  setMotivationMode('normal');  // ダイアログを閉じる
                  setShowReasonDialog(true);    // タスク入力ダイアログを開く
                },
                className: 'w-full py-3 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors'
              }, '散歩完了')
            )
          ),

          // タスク完了ダイアログ
          showTaskCompleteDialog && React.createElement('div', {
            className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50'
          },
            React.createElement('div', {
              className: 'bg-white p-6 rounded-lg max-w-sm w-full'
            },
              React.createElement('h3', {
                className: 'text-lg font-medium mb-4'
              }, 'タスク完了！'),
              React.createElement('div', {
                className: 'mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded'
              },
                React.createElement('div', {
                  className: 'text-sm text-gray-600 mb-1'
                }, '取り組んだ課題:'),
                React.createElement('div', {
                  className: 'text-sm font-medium text-gray-800'
                }, currentTaskReason)
              ),
              React.createElement('div', {
                className: 'mb-4'
              },
                React.createElement('label', {
                  className: 'block text-sm font-medium text-gray-700 mb-2'
                }, '実際に何をどこまでやりましたか？'),
                React.createElement('textarea', {
                  value: taskResult,
                  onChange: (e) => setTaskResult(e.target.value),
                  className: 'w-full p-3 border border-gray-300 rounded-lg resize-none',
                  rows: 3,
                  placeholder: '例：7人分の退院サマリを作成完了'
                })
              ),
              React.createElement('div', {
                className: 'flex space-x-2'
              },
                React.createElement('button', {
                  onClick: handleTaskComplete,
                  className: 'flex-1 py-2 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors'
                }, '記録する')
              )
            )
          ),
        )
      );
    };

    ReactDOM.render(React.createElement(AdaptivePomodoro), document.getElementById('root'));
